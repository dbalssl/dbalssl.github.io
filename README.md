# 리눅스 명령어

__top__

리눅스 명령어 top은 시스템의 실시간 성능을 모니터링하는데 사용됨

이 명령어를 통해 CPU 및 메모리 사용량, 실행 중인 프로세스, 시스템 부하 등을 실시간으로 확인 가능

top 명령어는 시스템 관리자가 시스템의 상태를 확인하고 성능 문제를 진단하는데 매우 유용

_<기본 사용법>_

top 명령어를 입력하면 터미널에 실시간으로 시스템의 상태가 표시됨. 화면은 주기적으로(기본값: 3초) 업데이트됨

_<출력 화면 구성>_

'top' 명령어를 실행하면 여러 줄의 정보가 표시됨

1.요약 정보(상단 몇 줄)

>시스템 시간 및 업타임: 현재 시간, 시스템이 가동된 시간 (업타임), 로그인한 사용자 수, 시스템 부하 평균 (1, 5, 15분 간격).

>프로세스 요약: 실행 중, 중지됨, 좀비 프로세스 등 전체 프로세스의 상태.

>CPU 사용량: 사용자 모드, 시스템 모드, 낮은 우선순위, 유휴 상태 등의 CPU 사용 비율.

>메모리 사용량: 총 메모리, 사용 중인 메모리, 자유 메모리, 버퍼/캐시 메모리.

>스왑 메모리 사용량: 총 스왑 메모리, 사용 중인 스왑, 자유 스왑, 스왑 입출력.

2.프로세스 목록(하단)

>PID: 프로세스 ID

>USER: 프로세스를 실행한 사용자

>PR: 프로세스의 우선순위

>NI: nice 값

>VIRT: 가상 메모리 사용량

>RES: 실제 메모리 사용량

>SHR: 공유 메모리 사용량

>S: 프로세스 상태 (R: 실행 중, S: 대기, T: 중지, Z: 좀비)

>%CPU: CPU 사용률

>%MEM: 메모리 사용률

>TIME+: 프로세스가 사용한 총 CPU 시간

>COMMAND: 실행된 명령어 이름

_<주요 명령어 옵션 및 키>_

top 명령어는 실행 중에도 다양한 키 입력을 통해 동작을 변경할 수 있음

>P: CPU 사용률 순으로 정렬

>M: 메모리 사용률 순으로 정렬

>T: 실행 시간/누적 시간 순으로 정렬

>c: 명령어/명령줄 토글

>k: 특정 프로세스 종료 (PID 입력 필요)

>r: 특정 프로세스의 우선순위 변경 (PID 및 새로운 우선순위 입력 필요)

>q: top 명령어 종료

>h: 도움말 표시

>u: 특정 사용자의 프로세스만 표시

_<사용 예제>_

1. 특정 사용자 프로세스만 보기
  >top -u username
  >
  >=특정 사용자(username)의 프로세스만 표시

2. 출력 업데이트 주기 변경
  >top -d 5
  >
  >=업데이트 주기를 5초로 변경

3. 배치 모드로 출력 저장
  >top -b -n 1 > top_output.txt
  >
  >=배치 모드 (-b)로 한 번만(-n 1) 출력하여 'top_output.txt' 파일에 저장함


__ps__

리눅스 명령어 ps는 현재 실행 중인 프로세스의 상태를 확인하는데 사용됨

'ps' 명령어는 시스템의 프로세스 상태를 일회성으로 스냅샷을 찍어 보여주며, 다양한 옵션을 통해 출력할 정보를 세부적으로 제어할 수 있음

_<기본 사용법>_

기본적으로 'ps' 명령어를 실행하면 현재 쉘 세션에서 실행 중인 프로세스의 간단한 목록이 출력됨

_<주요 옵션>_

>a: 모든 터미널에 속한 프로세스 표시 (데몬 프로세스 제외)

>e: 환경 변수 포함하여 출력

>f: 풀 포맷으로 출력 (상세 정보 포함)

>l: 긴 포맷으로 출력

>u: 특정 사용자의 프로세스 표시

>x: 터미널에 종속되지 않은 프로세스도 포함하여 출력 (데몬 프로세스 포함)

>-A 또는 -e: 모든 프로세스 표시

>-u username: 특정 사용자의 프로세스만 표시

>-p pid: 특정 PID의 프로세스만 표시

>--sort: 지정된 필드로 정렬

_<사용 예제>_

1. 기본 사용법
  >ps
  >
  >=현재 터미널에서 실행 중인  프로세스 목록을 표시

2. 모든 프로세스 보기
  >ps -A 또는 ps -e
  >
  >=시스템의 모든 프로세스를 표시

3. 상세 정보 출력
  >ps -f
  >
  >=프로세스의 상세 정보를 풀 포맷으로 출력함

4. 긴 포맷으로 출력
  >ps -l
  >
  >=프로세스를 긴 포맷으로 출력

5. 특정 사용자의 프로세스 보기
  >ps -u username
  >
  >=특정 사용자(username)의 프로세스를  표시

6. 터미널에 종속되지 않은 프로세스 포함
  >ps -x
  >
  >=터미널에 종속되지 않은 프로세스도 포함하여 표시

7. 모든 프로세스 상세 정보 보기
  >ps -ef
  >
  >=모든 프로세스를 풀 포맷으로 표시

8. 특정 PID의 프로세스 보기
  >ps -p pid
  >
  >=특정 프로세스 ID(pid)의 프로세스를  표시

9. 정렬된 출력
  >ps --sort=-%cpu
  >
  >=CPU 사용률 기준으로 프로세스를 정렬하여 표시함

_<출력 필드 설명>_

'ps' 명령어는 여러 필드를 포함하여 프로세스 정보를 출력함

>PID: 프로세스 ID

>TTY: 터미널 타입

>TIME: 프로세스가 사용한 총 CPU 시간

>CMD: 실행된 명령어 이름

>USER: 프로세스를 실행한 사용자

>%CPU: CPU 사용률

>%MEM: 메모리 사용률

>VSZ: 가상 메모리 크기 (KB 단위)

>RSS: 실제 메모리 사용량 (KB 단위)

>STAT: 프로세스 상태 코드 (R: 실행 중, S: 대기, D: 중단, Z: 좀비, T: 중지, W: 페이징, X: 종료됨)

_<예제 출력>_

<img width="654" alt="스크린샷 2567-05-31 오후 7 48 33" src="https://github.com/dbalssl/dbalssl.github.io/assets/171317657/c831d89e-aa5e-42b0-853f-7b776c228b0c">

>이 출력은 시스템의 모든 프로세스를 풀 포맷으로 표시한 예시


__jobs__

리눅스 명령어 jobs는 현재 쉘 세션에서 실행 중인 작업 목록을 표시하는 데 사용됨

특히, 백그라운드에서 실행 중인 작업이나 중지된 작업을 관리할 때 유용함

_<기본 사용법>_

jobs 이 명령어는 현재 쉘 세션에서 실행 중이거나 중지된 작업들의 상태를 보여줌

_<주요 옵션>_

>1. -l (long format): 각 작업의 프로세스 ID(PID)를 포함하여 출력합니다.
>2. -n (newly running): 상태가 변경된 작업만 표시합니다.
>3. -p (process IDs): 각 작업의 프로세스 ID만 출력합니다.
>4. -r (running): 실행 중인 작업만 표시합니다.
>5. -s (stopped): 중지된 작업만 표시합니다

_<사용 예제>_

1. 기본 사용법
  >jobs
  >
  >=현재 쉘에서 실행 중이거나 중지된 모든 작업의 상태를 표시

2. 상세 정보 출력(PID 포함)
  >jobs -l
  >
  >=각 작업의 프로세스 ID를 포함하여 상세 정보를 출력

3. 상태가 변경된 작업만 표시
  >jobs -n
  >
  >=상태가 변경된 작업만 표시

4. 프로세스 ID만 출력
  >jobs -p
  >
  >=각 작업의 프로세스 ID만 출력

5. 실행 중인 작업만 표시
  >jobs -r
  >
  >=현재 실행 중인 작업만 표시

6. 중지된 작업만 표시
  >jobs -s
  >
  >=중지된 작업만 표시

_<작업 제어>_

1. bg (background): 중지된 작업을 백그라운드에서 실행되도록 함
  >bg %1
  >
  >=작업 번호 1번을 백그라운드에서 실행

2. fg (foreground): 백그라운드나 중지된 작업을 포그라운드로 가져옴
  >fg %1
  >
  >=작업 번호 1번을 포그라운드로 가져옴

3. kill: 특정 작업을 종료합니다
  >kill %1
  >
  >=작업 번호 1번을 종료함

_<예제>_

<img width="663" alt="스크린샷 2567-05-31 오후 8 01 30" src="https://github.com/dbalssl/dbalssl.github.io/assets/171317657/60d04a69-d6cd-4a61-9a1c-ea70bfa2a5bc">

>위 예제에서는 sleep 100 & 명령어를 백그라운드에서 실행하고, jobs 명령어로 상태를 확인한 후, kill 명령어로 작업을 종료함


__kill__

리눅스 명령어 kill은 프로세스를 종료하거나 특정 신호를 보내기 위해 사용되는 명령어

이 명령어는 주로 프로세스 ID(PID)를 통해 특정 프로세스를 대상으로 작동하며, 다양한 신호를 보낼 수 있음

_<기본 사용법>_

kill [options] PID  여기서 'PID'는 종료하거나 신호를 보낼 프로세스의 ID

_<주요 옵션 및 신호>_

1. SIGTERM (15): 프로세스를 정상적으로 종료시키는 신호. 프로세스가 이 신호를 수신하면 종료 전 정리 작업을 수행할 수 있음
  >kill -15 <PID>
  >
  >=기본적으로 kill <PID>로 실행하면 SIGTERM 신호를 보냄

2. SIGKILL (9): 프로세스를 강제로 종료시키는 신호입니다. 프로세스가 이 신호를 수신하면 즉시 종료함
  >kill -9 <PID>
  
3. SIGHUP (1): 프로세스에 대해 종료 후 다시 시작하라는 신호. 주로 데몬 프로세스의 설정 파일을 다시 로드하도록 할 때 사용됨
  >kill -1

4. SIGSTOP: 프로세스를 일시 중지시키는 신호. 이 신호를 받은 프로세스는 멈추고, SIGCONT 신호를 받을 때까지 재개되지 않음
  >kill -STOP <PID>
  
5. SIGCONT: 일시 중지된 프로세스를 다시 시작하는 신호
  >kill -CONT <PID>

_<사용 예제>_

1. 프로세스 정상 종료(SIGTERM)
  >kill 12345
  >
  >=PID 12345인 프로세스에 'SIGTERM' 신호를 보내어 종료함

2. 프로세스 강제 종료(SIGKILL)
  >kill -9 12345
  >
  >=PID 12345인 프로세스를 즉시 강제 종료함

3. 프로세스 일시 중지(SIGSTOP)
  >kill -STOP 12345
  >
  >=PID 12345인 프로세스를 일시 중지시킴

4. 프로세스 재개(SIGCONT)
  >kill _CONT 12345
  >
  >=PID 12345인 일시 중지된 프로세스를 재개시킴

_<신호 목록 보기>_

>시스템에서 사용 가능한 모든 신호 목록을 보려면 다음 명령어를 사용
>
>kill -l

_<프로세스 ID 찾기>_

>특정 프로세스의 PID를 찾기 위해 ps, pgrep 또는 top 명령어를 사용할 수 있음

>예를 들어, ps 명령어를 사용하여 example-process의 PID를 찾을 수 있음
>
>ps aux | grep example-process

_<예제>_

<img width="580" alt="스크린샷 2567-05-31 오후 8 26 14" src="https://github.com/dbalssl/dbalssl.github.io/assets/171317657/9b29ce55-e5ef-4e75-9406-688316ac0346">

>위 예제에서는 ps aux | grep example-process 명령어로 example-process의 PID를 찾은 다음, kill 명령어로 해당 PID를 가진 프로세스를 종료함

